//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.segue` struct is generated, and contains static references to 3 view controllers.
  struct segue {
    /// This struct is generated for `LoginController`, and contains static references to 1 segues.
    struct loginController {
      /// Segue identifier `segue.selectCharacterToPlay`.
      static let segueSelectCharacterToPlay: Rswift.StoryboardSegueIdentifier<UIKit.UIStoryboardSegue, LoginController, SelectCharToPlayController> = Rswift.StoryboardSegueIdentifier(identifier: "segue.selectCharacterToPlay")

      #if os(iOS) || os(tvOS)
      /// Optionally returns a typed version of segue `segue.selectCharacterToPlay`.
      /// Returns nil if either the segue identifier, the source, destination, or segue types don't match.
      /// For use inside `prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?)`.
      static func segueSelectCharacterToPlay(segue: UIKit.UIStoryboardSegue) -> Rswift.TypedStoryboardSegueInfo<UIKit.UIStoryboardSegue, LoginController, SelectCharToPlayController>? {
        return Rswift.TypedStoryboardSegueInfo(segueIdentifier: R.segue.loginController.segueSelectCharacterToPlay, segue: segue)
      }
      #endif

      fileprivate init() {}
    }

    /// This struct is generated for `MainLoggerController`, and contains static references to 1 segues.
    struct mainLoggerController {
      /// Segue identifier `segue.statusBarStats`.
      static let segueStatusBarStats: Rswift.StoryboardSegueIdentifier<UIKit.UIStoryboardSegue, MainLoggerController, CharacterStatsController> = Rswift.StoryboardSegueIdentifier(identifier: "segue.statusBarStats")

      #if os(iOS) || os(tvOS)
      /// Optionally returns a typed version of segue `segue.statusBarStats`.
      /// Returns nil if either the segue identifier, the source, destination, or segue types don't match.
      /// For use inside `prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?)`.
      static func segueStatusBarStats(segue: UIKit.UIStoryboardSegue) -> Rswift.TypedStoryboardSegueInfo<UIKit.UIStoryboardSegue, MainLoggerController, CharacterStatsController>? {
        return Rswift.TypedStoryboardSegueInfo(segueIdentifier: R.segue.mainLoggerController.segueStatusBarStats, segue: segue)
      }
      #endif

      fileprivate init() {}
    }

    /// This struct is generated for `SelectCharToPlayController`, and contains static references to 2 segues.
    struct selectCharToPlayController {
      /// Segue identifier `createChar`.
      static let createChar: Rswift.StoryboardSegueIdentifier<UIKit.UIStoryboardSegue, SelectCharToPlayController, CreateCharController> = Rswift.StoryboardSegueIdentifier(identifier: "createChar")
      /// Segue identifier `goToLoggerTB`.
      static let goToLoggerTB: Rswift.StoryboardSegueIdentifier<UIKit.UIStoryboardSegue, SelectCharToPlayController, LoggerTabBarController> = Rswift.StoryboardSegueIdentifier(identifier: "goToLoggerTB")

      #if os(iOS) || os(tvOS)
      /// Optionally returns a typed version of segue `createChar`.
      /// Returns nil if either the segue identifier, the source, destination, or segue types don't match.
      /// For use inside `prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?)`.
      static func createChar(segue: UIKit.UIStoryboardSegue) -> Rswift.TypedStoryboardSegueInfo<UIKit.UIStoryboardSegue, SelectCharToPlayController, CreateCharController>? {
        return Rswift.TypedStoryboardSegueInfo(segueIdentifier: R.segue.selectCharToPlayController.createChar, segue: segue)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// Optionally returns a typed version of segue `goToLoggerTB`.
      /// Returns nil if either the segue identifier, the source, destination, or segue types don't match.
      /// For use inside `prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?)`.
      static func goToLoggerTB(segue: UIKit.UIStoryboardSegue) -> Rswift.TypedStoryboardSegueInfo<UIKit.UIStoryboardSegue, SelectCharToPlayController, LoggerTabBarController>? {
        return Rswift.TypedStoryboardSegueInfo(segueIdentifier: R.segue.selectCharToPlayController.goToLoggerTB, segue: segue)
      }
      #endif

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 7 storyboards.
  struct storyboard {
    /// Storyboard `Assistive`.
    static let assistive = _R.storyboard.assistive()
    /// Storyboard `CreateChar`.
    static let createChar = _R.storyboard.createChar()
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `LoggerTabBar`.
    static let loggerTabBar = _R.storyboard.loggerTabBar()
    /// Storyboard `Login`.
    static let login = _R.storyboard.login()
    /// Storyboard `MainLogger`.
    static let mainLogger = _R.storyboard.mainLogger()
    /// Storyboard `SelectCharToPlay`.
    static let selectCharToPlay = _R.storyboard.selectCharToPlay()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Assistive", bundle: ...)`
    static func assistive(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.assistive)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "CreateChar", bundle: ...)`
    static func createChar(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.createChar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LoggerTabBar", bundle: ...)`
    static func loggerTabBar(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.loggerTabBar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Login", bundle: ...)`
    static func login(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.login)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "MainLogger", bundle: ...)`
    static func mainLogger(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.mainLogger)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "SelectCharToPlay", bundle: ...)`
    static func selectCharToPlay(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.selectCharToPlay)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 13 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")
    /// Color `Blue`.
    static let blue = Rswift.ColorResource(bundle: R.hostingBundle, name: "Blue")
    /// Color `Brown`.
    static let brown = Rswift.ColorResource(bundle: R.hostingBundle, name: "Brown")
    /// Color `Creame`.
    static let creame = Rswift.ColorResource(bundle: R.hostingBundle, name: "Creame")
    /// Color `GrayText`.
    static let grayText = Rswift.ColorResource(bundle: R.hostingBundle, name: "GrayText")
    /// Color `Green`.
    static let green = Rswift.ColorResource(bundle: R.hostingBundle, name: "Green")
    /// Color `Red`.
    static let red = Rswift.ColorResource(bundle: R.hostingBundle, name: "Red")
    /// Color `Yellow`.
    static let yellow = Rswift.ColorResource(bundle: R.hostingBundle, name: "Yellow")
    /// Color `charBG`.
    static let charBG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charBG")
    /// Color `charHero1BG`.
    static let charHero1BG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charHero1BG")
    /// Color `charHero2BG`.
    static let charHero2BG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charHero2BG")
    /// Color `charPKBG`.
    static let charPKBG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charPKBG")
    /// Color `charPVPBG`.
    static let charPVPBG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charPVPBG")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Blue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func blue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.blue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Brown", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func brown(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.brown, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Creame", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func creame(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.creame, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "GrayText", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func grayText(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.grayText, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Green", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func green(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.green, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Red", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func red(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.red, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Yellow", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func yellow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.yellow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charBG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charBG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charBG, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charHero1BG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charHero1BG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charHero1BG, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charHero2BG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charHero2BG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charHero2BG, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charPKBG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charPKBG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charPKBG, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charPVPBG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charPVPBG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charPVPBG, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 10 files.
  struct file {
    /// Resource file `AlegreyaSC-Black.ttf`.
    static let alegreyaSCBlackTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Black", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-BlackItalic.ttf`.
    static let alegreyaSCBlackItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-BlackItalic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Bold.ttf`.
    static let alegreyaSCBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Bold", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-BoldItalic.ttf`.
    static let alegreyaSCBoldItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-BoldItalic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-ExtraBold.ttf`.
    static let alegreyaSCExtraBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-ExtraBold", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-ExtraBoldItalic.ttf`.
    static let alegreyaSCExtraBoldItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-ExtraBoldItalic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Italic.ttf`.
    static let alegreyaSCItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Italic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Medium.ttf`.
    static let alegreyaSCMediumTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Medium", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-MediumItalic.ttf`.
    static let alegreyaSCMediumItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-MediumItalic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Regular.ttf`.
    static let alegreyaSCRegularTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Regular", pathExtension: "ttf")

    /// `bundle.url(forResource: "AlegreyaSC-Black", withExtension: "ttf")`
    static func alegreyaSCBlackTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBlackTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-BlackItalic", withExtension: "ttf")`
    static func alegreyaSCBlackItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBlackItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Bold", withExtension: "ttf")`
    static func alegreyaSCBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-BoldItalic", withExtension: "ttf")`
    static func alegreyaSCBoldItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBoldItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-ExtraBold", withExtension: "ttf")`
    static func alegreyaSCExtraBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCExtraBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-ExtraBoldItalic", withExtension: "ttf")`
    static func alegreyaSCExtraBoldItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCExtraBoldItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Italic", withExtension: "ttf")`
    static func alegreyaSCItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Medium", withExtension: "ttf")`
    static func alegreyaSCMediumTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCMediumTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-MediumItalic", withExtension: "ttf")`
    static func alegreyaSCMediumItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCMediumItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Regular", withExtension: "ttf")`
    static func alegreyaSCRegularTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCRegularTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 10 fonts.
  struct font: Rswift.Validatable {
    /// Font `AlegreyaSC-BlackItalic`.
    static let alegreyaSCBlackItalic = Rswift.FontResource(fontName: "AlegreyaSC-BlackItalic")
    /// Font `AlegreyaSC-Black`.
    static let alegreyaSCBlack = Rswift.FontResource(fontName: "AlegreyaSC-Black")
    /// Font `AlegreyaSC-BoldItalic`.
    static let alegreyaSCBoldItalic = Rswift.FontResource(fontName: "AlegreyaSC-BoldItalic")
    /// Font `AlegreyaSC-Bold`.
    static let alegreyaSCBold = Rswift.FontResource(fontName: "AlegreyaSC-Bold")
    /// Font `AlegreyaSC-ExtraBoldItalic`.
    static let alegreyaSCExtraBoldItalic = Rswift.FontResource(fontName: "AlegreyaSC-ExtraBoldItalic")
    /// Font `AlegreyaSC-ExtraBold`.
    static let alegreyaSCExtraBold = Rswift.FontResource(fontName: "AlegreyaSC-ExtraBold")
    /// Font `AlegreyaSC-Italic`.
    static let alegreyaSCItalic = Rswift.FontResource(fontName: "AlegreyaSC-Italic")
    /// Font `AlegreyaSC-MediumItalic`.
    static let alegreyaSCMediumItalic = Rswift.FontResource(fontName: "AlegreyaSC-MediumItalic")
    /// Font `AlegreyaSC-Medium`.
    static let alegreyaSCMedium = Rswift.FontResource(fontName: "AlegreyaSC-Medium")
    /// Font `AlegreyaSC-Regular`.
    static let alegreyaSCRegular = Rswift.FontResource(fontName: "AlegreyaSC-Regular")

    /// `UIFont(name: "AlegreyaSC-Black", size: ...)`
    static func alegreyaSCBlack(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBlack, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-BlackItalic", size: ...)`
    static func alegreyaSCBlackItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBlackItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Bold", size: ...)`
    static func alegreyaSCBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBold, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-BoldItalic", size: ...)`
    static func alegreyaSCBoldItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBoldItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-ExtraBold", size: ...)`
    static func alegreyaSCExtraBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCExtraBold, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-ExtraBoldItalic", size: ...)`
    static func alegreyaSCExtraBoldItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCExtraBoldItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Italic", size: ...)`
    static func alegreyaSCItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Medium", size: ...)`
    static func alegreyaSCMedium(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCMedium, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-MediumItalic", size: ...)`
    static func alegreyaSCMediumItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCMediumItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Regular", size: ...)`
    static func alegreyaSCRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCRegular, size: size)
    }

    static func validate() throws {
      if R.font.alegreyaSCBlack(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Black' could not be loaded, is 'AlegreyaSC-Black.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCBlackItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-BlackItalic' could not be loaded, is 'AlegreyaSC-BlackItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Bold' could not be loaded, is 'AlegreyaSC-Bold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCBoldItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-BoldItalic' could not be loaded, is 'AlegreyaSC-BoldItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCExtraBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-ExtraBold' could not be loaded, is 'AlegreyaSC-ExtraBold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCExtraBoldItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-ExtraBoldItalic' could not be loaded, is 'AlegreyaSC-ExtraBoldItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Italic' could not be loaded, is 'AlegreyaSC-Italic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCMedium(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Medium' could not be loaded, is 'AlegreyaSC-Medium.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCMediumItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-MediumItalic' could not be loaded, is 'AlegreyaSC-MediumItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Regular' could not be loaded, is 'AlegreyaSC-Regular.ttf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.id` struct is generated, and contains static references to accessibility identifiers.
  struct id {
    struct createChar {
      /// Accessibility identifier `ARCHER`.
      static let archeR: String = "ARCHER"
      /// Accessibility identifier `ASSASSIN`.
      static let assassiN: String = "ASSASSIN"
      /// Accessibility identifier `WARRIOR`.
      static let warrioR: String = "WARRIOR"
      /// Accessibility identifier `WIZARD`.
      static let wizarD: String = "WIZARD"

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 27 images.
  struct image {
    /// Image `AppImage`.
    static let appImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "AppImage")
    /// Image `AppName`.
    static let appName = Rswift.ImageResource(bundle: R.hostingBundle, name: "AppName")
    /// Image `Button`.
    static let button = Rswift.ImageResource(bundle: R.hostingBundle, name: "Button")
    /// Image `archerImage`.
    static let archerImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "archerImage")
    /// Image `assassinImage`.
    static let assassinImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "assassinImage")
    /// Image `backgroundFrame`.
    static let backgroundFrame = Rswift.ImageResource(bundle: R.hostingBundle, name: "backgroundFrame")
    /// Image `barHP`.
    static let barHP = Rswift.ImageResource(bundle: R.hostingBundle, name: "barHP")
    /// Image `barMP`.
    static let barMP = Rswift.ImageResource(bundle: R.hostingBundle, name: "barMP")
    /// Image `buttonLightBrown`.
    static let buttonLightBrown = Rswift.ImageResource(bundle: R.hostingBundle, name: "buttonLightBrown")
    /// Image `checkboxOff`.
    static let checkboxOff = Rswift.ImageResource(bundle: R.hostingBundle, name: "checkboxOff")
    /// Image `checkboxOn`.
    static let checkboxOn = Rswift.ImageResource(bundle: R.hostingBundle, name: "checkboxOn")
    /// Image `closeButtonRed`.
    static let closeButtonRed = Rswift.ImageResource(bundle: R.hostingBundle, name: "closeButtonRed")
    /// Image `icArcherBow`.
    static let icArcherBow = Rswift.ImageResource(bundle: R.hostingBundle, name: "icArcherBow")
    /// Image `icAssasignShuriken`.
    static let icAssasignShuriken = Rswift.ImageResource(bundle: R.hostingBundle, name: "icAssasignShuriken")
    /// Image `icButtonMove`.
    static let icButtonMove = Rswift.ImageResource(bundle: R.hostingBundle, name: "icButtonMove")
    /// Image `icFacebook`.
    static let icFacebook = Rswift.ImageResource(bundle: R.hostingBundle, name: "icFacebook")
    /// Image `icGoogle`.
    static let icGoogle = Rswift.ImageResource(bundle: R.hostingBundle, name: "icGoogle")
    /// Image `icInventoryTabBarItem`.
    static let icInventoryTabBarItem = Rswift.ImageResource(bundle: R.hostingBundle, name: "icInventoryTabBarItem")
    /// Image `icLogsTabBarItem`.
    static let icLogsTabBarItem = Rswift.ImageResource(bundle: R.hostingBundle, name: "icLogsTabBarItem")
    /// Image `icMageStuff`.
    static let icMageStuff = Rswift.ImageResource(bundle: R.hostingBundle, name: "icMageStuff")
    /// Image `icMap`.
    static let icMap = Rswift.ImageResource(bundle: R.hostingBundle, name: "icMap")
    /// Image `icVK`.
    static let icVK = Rswift.ImageResource(bundle: R.hostingBundle, name: "icVK")
    /// Image `icWarSword`.
    static let icWarSword = Rswift.ImageResource(bundle: R.hostingBundle, name: "icWarSword")
    /// Image `mageImage`.
    static let mageImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "mageImage")
    /// Image `mobGrayRat`.
    static let mobGrayRat = Rswift.ImageResource(bundle: R.hostingBundle, name: "mobGrayRat")
    /// Image `notSelectableCellFrame`.
    static let notSelectableCellFrame = Rswift.ImageResource(bundle: R.hostingBundle, name: "notSelectableCellFrame")
    /// Image `warriorImage`.
    static let warriorImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "warriorImage")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "AppImage", bundle: ..., traitCollection: ...)`
    static func appImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.appImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "AppName", bundle: ..., traitCollection: ...)`
    static func appName(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.appName, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Button", bundle: ..., traitCollection: ...)`
    static func button(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.button, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "archerImage", bundle: ..., traitCollection: ...)`
    static func archerImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.archerImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "assassinImage", bundle: ..., traitCollection: ...)`
    static func assassinImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.assassinImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "backgroundFrame", bundle: ..., traitCollection: ...)`
    static func backgroundFrame(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.backgroundFrame, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "barHP", bundle: ..., traitCollection: ...)`
    static func barHP(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.barHP, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "barMP", bundle: ..., traitCollection: ...)`
    static func barMP(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.barMP, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "buttonLightBrown", bundle: ..., traitCollection: ...)`
    static func buttonLightBrown(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.buttonLightBrown, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "checkboxOff", bundle: ..., traitCollection: ...)`
    static func checkboxOff(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.checkboxOff, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "checkboxOn", bundle: ..., traitCollection: ...)`
    static func checkboxOn(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.checkboxOn, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "closeButtonRed", bundle: ..., traitCollection: ...)`
    static func closeButtonRed(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.closeButtonRed, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icArcherBow", bundle: ..., traitCollection: ...)`
    static func icArcherBow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icArcherBow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icAssasignShuriken", bundle: ..., traitCollection: ...)`
    static func icAssasignShuriken(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icAssasignShuriken, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icButtonMove", bundle: ..., traitCollection: ...)`
    static func icButtonMove(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icButtonMove, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icFacebook", bundle: ..., traitCollection: ...)`
    static func icFacebook(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icFacebook, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icGoogle", bundle: ..., traitCollection: ...)`
    static func icGoogle(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icGoogle, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icInventoryTabBarItem", bundle: ..., traitCollection: ...)`
    static func icInventoryTabBarItem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icInventoryTabBarItem, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icLogsTabBarItem", bundle: ..., traitCollection: ...)`
    static func icLogsTabBarItem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icLogsTabBarItem, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icMageStuff", bundle: ..., traitCollection: ...)`
    static func icMageStuff(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icMageStuff, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icMap", bundle: ..., traitCollection: ...)`
    static func icMap(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icMap, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icVK", bundle: ..., traitCollection: ...)`
    static func icVK(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icVK, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icWarSword", bundle: ..., traitCollection: ...)`
    static func icWarSword(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icWarSword, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "mageImage", bundle: ..., traitCollection: ...)`
    static func mageImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mageImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "mobGrayRat", bundle: ..., traitCollection: ...)`
    static func mobGrayRat(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mobGrayRat, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "notSelectableCellFrame", bundle: ..., traitCollection: ...)`
    static func notSelectableCellFrame(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.notSelectableCellFrame, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "warriorImage", bundle: ..., traitCollection: ...)`
    static func warriorImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.warriorImage, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"
            static let uiSceneStoryboardFile = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneStoryboardFile") ?? "Login"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 13 nibs.
  struct nib {
    /// Nib `AddCharCell`.
    static let addCharCell = _R.nib._AddCharCell()
    /// Nib `AlertView`.
    static let alertView = _R.nib._AlertView()
    /// Nib `ButtonWImage`.
    static let buttonWImage = _R.nib._ButtonWImage()
    /// Nib `ButtonWOImage`.
    static let buttonWOImage = _R.nib._ButtonWOImage()
    /// Nib `CharStatusBar`.
    static let charStatusBar = _R.nib._CharStatusBar()
    /// Nib `CharacterPickCell`.
    static let characterPickCell = _R.nib._CharacterPickCell()
    /// Nib `CharsInLocationCell`.
    static let charsInLocationCell = _R.nib._CharsInLocationCell()
    /// Nib `LocationsMap`.
    static let locationsMap = _R.nib._LocationsMap()
    /// Nib `LogCell`.
    static let logCell = _R.nib._LogCell()
    /// Nib `MapCell`.
    static let mapCell = _R.nib._MapCell()
    /// Nib `NestCell`.
    static let nestCell = _R.nib._NestCell()
    /// Nib `NestsSelect`.
    static let nestsSelect = _R.nib._NestsSelect()
    /// Nib `StatCell`.
    static let statCell = _R.nib._StatCell()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AddCharCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.addCharCell) instead")
    static func addCharCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.addCharCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AlertView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.alertView) instead")
    static func alertView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.alertView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ButtonWImage", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.buttonWImage) instead")
    static func buttonWImage(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.buttonWImage)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ButtonWOImage", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.buttonWOImage) instead")
    static func buttonWOImage(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.buttonWOImage)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CharStatusBar", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.charStatusBar) instead")
    static func charStatusBar(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.charStatusBar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CharacterPickCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.characterPickCell) instead")
    static func characterPickCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.characterPickCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CharsInLocationCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.charsInLocationCell) instead")
    static func charsInLocationCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.charsInLocationCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "LocationsMap", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.locationsMap) instead")
    static func locationsMap(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.locationsMap)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "LogCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.logCell) instead")
    static func logCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.logCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MapCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.mapCell) instead")
    static func mapCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.mapCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "NestCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.nestCell) instead")
    static func nestCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.nestCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "NestsSelect", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.nestsSelect) instead")
    static func nestsSelect(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.nestsSelect)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "StatCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.statCell) instead")
    static func statCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.statCell)
    }
    #endif

    static func addCharCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AddCharCell? {
      return R.nib.addCharCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AddCharCell
    }

    static func alertView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AlertView? {
      return R.nib.alertView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AlertView
    }

    static func buttonWImage(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
      return R.nib.buttonWImage.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
    }

    static func buttonWOImage(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
      return R.nib.buttonWOImage.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
    }

    static func charStatusBar(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.charStatusBar.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func characterPickCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharacterPickCell? {
      return R.nib.characterPickCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharacterPickCell
    }

    static func charsInLocationCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharsInLocationCell? {
      return R.nib.charsInLocationCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharsInLocationCell
    }

    static func locationsMap(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> LocationsMap? {
      return R.nib.locationsMap.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? LocationsMap
    }

    static func logCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> LogCell? {
      return R.nib.logCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? LogCell
    }

    static func mapCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> MapCell? {
      return R.nib.mapCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? MapCell
    }

    static func nestCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> NestCell? {
      return R.nib.nestCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? NestCell
    }

    static func nestsSelect(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> NestsSelect? {
      return R.nib.nestsSelect.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? NestsSelect
    }

    static func statCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> StatCell? {
      return R.nib.statCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? StatCell
    }

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 6 localization tables.
  struct string {
    /// This `R.string.createChar` struct is generated, and contains static references to 9 localization keys.
    struct createChar {
      /// en translation: Desaring
      ///
      /// Locales: en, ru
      static let ilPZA13WText = Rswift.StringResource(key: "ilP-ZA-13W.text", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Mage
      ///
      /// Locales: en, ru
      static let wLx6YCLrText = Rswift.StringResource(key: "WLx-6Y-CLr.text", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Title
      ///
      /// Locales: en, ru
      static let blf6NHqgTitle = Rswift.StringResource(key: "BLF-6N-Hqg.title", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You character nickname
      ///
      /// Locales: en, ru
      static let ilPZA13WPlaceholder = Rswift.StringResource(key: "ilP-ZA-13W.placeholder", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 
      ///
      /// Locales: en, ru
      static let g5RR66a3Text = Rswift.StringResource(key: "G5R-R6-6a3.text", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation:  
      ///
      /// Locales: en, ru
      static let bdFS1QLeText = Rswift.StringResource(key: "BdF-S1-qLe.text", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 
      ///
      /// Locales: en, ru
      static let gtwKrRjiText = Rswift.StringResource(key: "gtw-kr-Rji.text", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 
      ///
      /// Locales: en, ru
      static let fnDDYRjText = Rswift.StringResource(key: "6Fn-dD-YRj.text", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation:        .       .
      ///
      /// Locales: en, ru
      static let aCI7XHvrText = Rswift.StringResource(key: "aCI-7X-Hvr.text", tableName: "CreateChar", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)

      /// en translation: Desaring
      ///
      /// Locales: en, ru
      static func ilPZA13WText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ilP-ZA-13W.text", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "ilP-ZA-13W.text"
        }

        return NSLocalizedString("ilP-ZA-13W.text", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      /// en translation: Mage
      ///
      /// Locales: en, ru
      static func wLx6YCLrText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("WLx-6Y-CLr.text", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "WLx-6Y-CLr.text"
        }

        return NSLocalizedString("WLx-6Y-CLr.text", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      /// en translation: Title
      ///
      /// Locales: en, ru
      static func blf6NHqgTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("BLF-6N-Hqg.title", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "BLF-6N-Hqg.title"
        }

        return NSLocalizedString("BLF-6N-Hqg.title", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      /// en translation: You character nickname
      ///
      /// Locales: en, ru
      static func ilPZA13WPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ilP-ZA-13W.placeholder", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "ilP-ZA-13W.placeholder"
        }

        return NSLocalizedString("ilP-ZA-13W.placeholder", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      /// en translation: 
      ///
      /// Locales: en, ru
      static func g5RR66a3Text(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("G5R-R6-6a3.text", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "G5R-R6-6a3.text"
        }

        return NSLocalizedString("G5R-R6-6a3.text", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      /// en translation:  
      ///
      /// Locales: en, ru
      static func bdFS1QLeText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("BdF-S1-qLe.text", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "BdF-S1-qLe.text"
        }

        return NSLocalizedString("BdF-S1-qLe.text", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      /// en translation: 
      ///
      /// Locales: en, ru
      static func gtwKrRjiText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("gtw-kr-Rji.text", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "gtw-kr-Rji.text"
        }

        return NSLocalizedString("gtw-kr-Rji.text", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      /// en translation: 
      ///
      /// Locales: en, ru
      static func fnDDYRjText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("6Fn-dD-YRj.text", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "6Fn-dD-YRj.text"
        }

        return NSLocalizedString("6Fn-dD-YRj.text", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      /// en translation:        .       .
      ///
      /// Locales: en, ru
      static func aCI7XHvrText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("aCI-7X-Hvr.text", tableName: "CreateChar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "CreateChar", preferredLanguages: preferredLanguages) else {
          return "aCI-7X-Hvr.text"
        }

        return NSLocalizedString("aCI-7X-Hvr.text", tableName: "CreateChar", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.infoPlist` struct is generated, and contains static references to 0 localization keys.
    struct infoPlist {
      fileprivate init() {}
    }

    /// This `R.string.launchScreen` struct is generated, and contains static references to 0 localization keys.
    struct launchScreen {
      fileprivate init() {}
    }

    /// This `R.string.localizable` struct is generated, and contains static references to 4 localization keys.
    struct localizable {
      /// en translation: Cannot read data received from server.
      ///
      /// Locales: en, ru
      static let parserError = Rswift.StringResource(key: "parserError", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Login required
      ///
      /// Locales: en, ru
      static let errorMessageNotAuthorized = Rswift.StringResource(key: "errorMessageNotAuthorized", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: No internet connection
      ///
      /// Locales: en, ru
      static let errorMessageInternetConnection = Rswift.StringResource(key: "errorMessageInternetConnection", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Sorry, something went wrong. Try again later.
      ///
      /// Locales: en, ru
      static let errorMessageDefault = Rswift.StringResource(key: "errorMessageDefault", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)

      /// en translation: Cannot read data received from server.
      ///
      /// Locales: en, ru
      static func parserError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("parserError", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "parserError"
        }

        return NSLocalizedString("parserError", bundle: bundle, comment: "")
      }

      /// en translation: Login required
      ///
      /// Locales: en, ru
      static func errorMessageNotAuthorized(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageNotAuthorized", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageNotAuthorized"
        }

        return NSLocalizedString("errorMessageNotAuthorized", bundle: bundle, comment: "")
      }

      /// en translation: No internet connection
      ///
      /// Locales: en, ru
      static func errorMessageInternetConnection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageInternetConnection", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageInternetConnection"
        }

        return NSLocalizedString("errorMessageInternetConnection", bundle: bundle, comment: "")
      }

      /// en translation: Sorry, something went wrong. Try again later.
      ///
      /// Locales: en, ru
      static func errorMessageDefault(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageDefault", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageDefault"
        }

        return NSLocalizedString("errorMessageDefault", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.loggerTabBar` struct is generated, and contains static references to 2 localization keys.
    struct loggerTabBar {
      /// ru translation: Item
      ///
      /// Locales: ru
      static let cvtDLKQcTitle = Rswift.StringResource(key: "cvt-DL-KQc.title", tableName: "LoggerTabBar", bundle: R.hostingBundle, locales: ["ru"], comment: nil)
      /// ru translation: Item
      ///
      /// Locales: ru
      static let dEYMjPxbTitle = Rswift.StringResource(key: "dEY-mj-pxb.title", tableName: "LoggerTabBar", bundle: R.hostingBundle, locales: ["ru"], comment: nil)

      /// ru translation: Item
      ///
      /// Locales: ru
      static func cvtDLKQcTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("cvt-DL-KQc.title", tableName: "LoggerTabBar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LoggerTabBar", preferredLanguages: preferredLanguages) else {
          return "cvt-DL-KQc.title"
        }

        return NSLocalizedString("cvt-DL-KQc.title", tableName: "LoggerTabBar", bundle: bundle, comment: "")
      }

      /// ru translation: Item
      ///
      /// Locales: ru
      static func dEYMjPxbTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dEY-mj-pxb.title", tableName: "LoggerTabBar", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LoggerTabBar", preferredLanguages: preferredLanguages) else {
          return "dEY-mj-pxb.title"
        }

        return NSLocalizedString("dEY-mj-pxb.title", tableName: "LoggerTabBar", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.login` struct is generated, and contains static references to 20 localization keys.
    struct login {
      /// en translation: Back
      ///
      /// Locales: ru, en
      static let dlrQ1FyDTitle = Rswift.StringResource(key: "dlr-q1-FyD.title", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Back
      ///
      /// Locales: ru, en
      static let k7HERWG5Title = Rswift.StringResource(key: "K7H-eR-wG5.title", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Email
      ///
      /// Locales: ru, en
      static let n2ZSnE0zPlaceholder = Rswift.StringResource(key: "n2Z-Sn-E0z.placeholder", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Email
      ///
      /// Locales: ru, en
      static let uXnCdMTvPlaceholder = Rswift.StringResource(key: "UXn-cd-mTv.placeholder", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Enter your Email:
      ///
      /// Locales: ru, en
      static let jsMNpWmGText = Rswift.StringResource(key: "JsM-np-wmG.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: New Password
      ///
      /// Locales: ru, en
      static let iYwLRUJkPlaceholder = Rswift.StringResource(key: "IYw-lR-uJk.placeholder", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Nickname
      ///
      /// Locales: ru, en
      static let e4iFHKigPlaceholder = Rswift.StringResource(key: "e4i-fH-Kig.placeholder", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Password
      ///
      /// Locales: ru, en
      static let rhwUlL0dPlaceholder = Rswift.StringResource(key: "Rhw-Ul-L0d.placeholder", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Password:
      ///
      /// Locales: ru, en
      static let ue5SkUA8Text = Rswift.StringResource(key: "Ue5-Sk-UA8.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Pwd123
      ///
      /// Locales: ru, en
      static let iYwLRUJkText = Rswift.StringResource(key: "IYw-lR-uJk.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Pwd123
      ///
      /// Locales: ru, en
      static let jUpLdEaKText = Rswift.StringResource(key: "JUp-ld-eaK.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Pwd123
      ///
      /// Locales: ru, en
      static let rhwUlL0dText = Rswift.StringResource(key: "Rhw-Ul-L0d.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Registration
      ///
      /// Locales: ru, en
      static let hwFPgIsbTitle = Rswift.StringResource(key: "hwF-pg-isb.title", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Registration
      ///
      /// Locales: ru, en
      static let pyYHkQTzNormalTitle = Rswift.StringResource(key: "PyY-hk-qTz.normalTitle", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Repeat Password
      ///
      /// Locales: ru, en
      static let jUpLdEaKPlaceholder = Rswift.StringResource(key: "JUp-ld-eaK.placeholder", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Repeat password:
      ///
      /// Locales: ru, en
      static let vfaNWRjfText = Rswift.StringResource(key: "Vfa-nW-Rjf.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: Type password:
      ///
      /// Locales: ru, en
      static let ryyDpVbYText = Rswift.StringResource(key: "Ryy-Dp-vbY.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: testUser1
      ///
      /// Locales: ru, en
      static let e4iFHKigText = Rswift.StringResource(key: "e4i-fH-Kig.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: testUser1
      ///
      /// Locales: ru, en
      static let n2ZSnE0zText = Rswift.StringResource(key: "n2Z-Sn-E0z.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)
      /// en translation: testUser1@mail.ru
      ///
      /// Locales: ru, en
      static let uXnCdMTvText = Rswift.StringResource(key: "UXn-cd-mTv.text", tableName: "Login", bundle: R.hostingBundle, locales: ["ru", "en"], comment: nil)

      /// en translation: Back
      ///
      /// Locales: ru, en
      static func dlrQ1FyDTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dlr-q1-FyD.title", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "dlr-q1-FyD.title"
        }

        return NSLocalizedString("dlr-q1-FyD.title", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Back
      ///
      /// Locales: ru, en
      static func k7HERWG5Title(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("K7H-eR-wG5.title", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "K7H-eR-wG5.title"
        }

        return NSLocalizedString("K7H-eR-wG5.title", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Email
      ///
      /// Locales: ru, en
      static func n2ZSnE0zPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("n2Z-Sn-E0z.placeholder", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "n2Z-Sn-E0z.placeholder"
        }

        return NSLocalizedString("n2Z-Sn-E0z.placeholder", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Email
      ///
      /// Locales: ru, en
      static func uXnCdMTvPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("UXn-cd-mTv.placeholder", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "UXn-cd-mTv.placeholder"
        }

        return NSLocalizedString("UXn-cd-mTv.placeholder", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Enter your Email:
      ///
      /// Locales: ru, en
      static func jsMNpWmGText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("JsM-np-wmG.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "JsM-np-wmG.text"
        }

        return NSLocalizedString("JsM-np-wmG.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: New Password
      ///
      /// Locales: ru, en
      static func iYwLRUJkPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("IYw-lR-uJk.placeholder", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "IYw-lR-uJk.placeholder"
        }

        return NSLocalizedString("IYw-lR-uJk.placeholder", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Nickname
      ///
      /// Locales: ru, en
      static func e4iFHKigPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("e4i-fH-Kig.placeholder", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "e4i-fH-Kig.placeholder"
        }

        return NSLocalizedString("e4i-fH-Kig.placeholder", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Password
      ///
      /// Locales: ru, en
      static func rhwUlL0dPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Rhw-Ul-L0d.placeholder", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "Rhw-Ul-L0d.placeholder"
        }

        return NSLocalizedString("Rhw-Ul-L0d.placeholder", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Password:
      ///
      /// Locales: ru, en
      static func ue5SkUA8Text(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Ue5-Sk-UA8.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "Ue5-Sk-UA8.text"
        }

        return NSLocalizedString("Ue5-Sk-UA8.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Pwd123
      ///
      /// Locales: ru, en
      static func iYwLRUJkText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("IYw-lR-uJk.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "IYw-lR-uJk.text"
        }

        return NSLocalizedString("IYw-lR-uJk.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Pwd123
      ///
      /// Locales: ru, en
      static func jUpLdEaKText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("JUp-ld-eaK.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "JUp-ld-eaK.text"
        }

        return NSLocalizedString("JUp-ld-eaK.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Pwd123
      ///
      /// Locales: ru, en
      static func rhwUlL0dText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Rhw-Ul-L0d.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "Rhw-Ul-L0d.text"
        }

        return NSLocalizedString("Rhw-Ul-L0d.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Registration
      ///
      /// Locales: ru, en
      static func hwFPgIsbTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("hwF-pg-isb.title", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "hwF-pg-isb.title"
        }

        return NSLocalizedString("hwF-pg-isb.title", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Registration
      ///
      /// Locales: ru, en
      static func pyYHkQTzNormalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("PyY-hk-qTz.normalTitle", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "PyY-hk-qTz.normalTitle"
        }

        return NSLocalizedString("PyY-hk-qTz.normalTitle", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Repeat Password
      ///
      /// Locales: ru, en
      static func jUpLdEaKPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("JUp-ld-eaK.placeholder", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "JUp-ld-eaK.placeholder"
        }

        return NSLocalizedString("JUp-ld-eaK.placeholder", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Repeat password:
      ///
      /// Locales: ru, en
      static func vfaNWRjfText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Vfa-nW-Rjf.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "Vfa-nW-Rjf.text"
        }

        return NSLocalizedString("Vfa-nW-Rjf.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: Type password:
      ///
      /// Locales: ru, en
      static func ryyDpVbYText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Ryy-Dp-vbY.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "Ryy-Dp-vbY.text"
        }

        return NSLocalizedString("Ryy-Dp-vbY.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: testUser1
      ///
      /// Locales: ru, en
      static func e4iFHKigText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("e4i-fH-Kig.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "e4i-fH-Kig.text"
        }

        return NSLocalizedString("e4i-fH-Kig.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: testUser1
      ///
      /// Locales: ru, en
      static func n2ZSnE0zText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("n2Z-Sn-E0z.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "n2Z-Sn-E0z.text"
        }

        return NSLocalizedString("n2Z-Sn-E0z.text", tableName: "Login", bundle: bundle, comment: "")
      }

      /// en translation: testUser1@mail.ru
      ///
      /// Locales: ru, en
      static func uXnCdMTvText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("UXn-cd-mTv.text", tableName: "Login", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Login", preferredLanguages: preferredLanguages) else {
          return "UXn-cd-mTv.text"
        }

        return NSLocalizedString("UXn-cd-mTv.text", tableName: "Login", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _AddCharCell.validate()
      try _AlertView.validate()
      try _ButtonWImage.validate()
      try _ButtonWOImage.validate()
      try _CharStatusBar.validate()
      try _CharacterPickCell.validate()
      try _CharsInLocationCell.validate()
      try _LocationsMap.validate()
      try _NestCell.validate()
      try _NestsSelect.validate()
    }

    struct _AddCharCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AddCharCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AddCharCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AddCharCell
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "plus") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'plus' is used in nib 'AddCharCell', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'AddCharCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _AlertView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AlertView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AlertView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AlertView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "backgroundFrame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'backgroundFrame' is used in nib 'AlertView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'AlertView', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ButtonWImage: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "ButtonWImage"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
      }

      static func validate() throws {
        if UIKit.UIImage(named: "Button", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'Button' is used in nib 'ButtonWImage', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icMageStuff", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icMageStuff' is used in nib 'ButtonWImage', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'ButtonWImage', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ButtonWOImage: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "ButtonWOImage"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
      }

      static func validate() throws {
        if UIKit.UIImage(named: "Button", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'Button' is used in nib 'ButtonWOImage', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'ButtonWOImage', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CharStatusBar: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CharStatusBar"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "barHP", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'barHP' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "barMP", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'barMP' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CharacterPickCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CharacterPickCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharacterPickCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharacterPickCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "mageImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'mageImage' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Green", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Green' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CharsInLocationCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CharsInLocationCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharsInLocationCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharsInLocationCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icWarSword", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icWarSword' is used in nib 'CharsInLocationCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in nib 'CharsInLocationCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _LocationsMap: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "LocationsMap"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> LocationsMap? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? LocationsMap
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icMap", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icMap' is used in nib 'LocationsMap', but couldn't be loaded.") }
        if UIKit.UIImage(named: "buttonLightBrown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'buttonLightBrown' is used in nib 'LocationsMap', but couldn't be loaded.") }
        if UIKit.UIImage(named: "closeButtonRed", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'closeButtonRed' is used in nib 'LocationsMap', but couldn't be loaded.") }
        if UIKit.UIImage(named: "backgroundFrame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'backgroundFrame' is used in nib 'LocationsMap', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in nib 'LocationsMap', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'LocationsMap', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _LogCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "LogCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> LogCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? LogCell
      }

      fileprivate init() {}
    }

    struct _MapCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "MapCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> MapCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? MapCell
      }

      fileprivate init() {}
    }

    struct _NestCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "NestCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> NestCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? NestCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "checkboxOff", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'checkboxOff' is used in nib 'NestCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "notSelectableCellFrame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'notSelectableCellFrame' is used in nib 'NestCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }

    struct _NestsSelect: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "NestsSelect"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> NestsSelect? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? NestsSelect
      }

      static func validate() throws {
        if UIKit.UIImage(named: "buttonLightBrown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'buttonLightBrown' is used in nib 'NestsSelect', but couldn't be loaded.") }
        if UIKit.UIImage(named: "backgroundFrame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'backgroundFrame' is used in nib 'NestsSelect', but couldn't be loaded.") }
        if UIKit.UIImage(named: "closeButtonRed", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'closeButtonRed' is used in nib 'NestsSelect', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in nib 'NestsSelect', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'NestsSelect', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _StatCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "StatCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> StatCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? StatCell
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try assistive.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try createChar.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try loggerTabBar.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try login.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try mainLogger.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try selectCharToPlay.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct assistive: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let assistiveNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "AssistiveNav")
      let bundle = R.hostingBundle
      let name = "Assistive"

      func assistiveNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: assistiveNav)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icInventoryTabBarItem", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icInventoryTabBarItem' is used in storyboard 'Assistive', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'Assistive', but couldn't be loaded.") }
        }
        if _R.storyboard.assistive().assistiveNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'assistiveNav' could not be loaded from storyboard 'Assistive' as 'UIKit.UINavigationController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct createChar: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = CreateCharController

      let bundle = R.hostingBundle
      let createCharVC = StoryboardViewControllerResource<CreateCharController>(identifier: "CreateCharVC")
      let name = "CreateChar"

      func createCharVC(_: Void = ()) -> CreateCharController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: createCharVC)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "assassinImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'assassinImage' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icMageStuff", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icMageStuff' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "archerImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'archerImage' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icWarSword", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icWarSword' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.left") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.left' is used in storyboard 'CreateChar', but couldn't be loaded.") } }
        if UIKit.UIImage(named: "icAssasignShuriken", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icAssasignShuriken' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "warriorImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'warriorImage' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icArcherBow", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icArcherBow' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "mageImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'mageImage' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'CreateChar', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        }
        if _R.storyboard.createChar().createCharVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'createCharVC' could not be loaded from storyboard 'CreateChar' as 'CreateCharController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct loggerTabBar: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = LoggerTabBarController

      let bundle = R.hostingBundle
      let loggerTabBarVC = StoryboardViewControllerResource<LoggerTabBarController>(identifier: "LoggerTabBarVC")
      let name = "LoggerTabBar"

      func loggerTabBarVC(_: Void = ()) -> LoggerTabBarController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: loggerTabBarVC)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'LoggerTabBar', but couldn't be loaded.") }
        }
        if _R.storyboard.loggerTabBar().loggerTabBarVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'loggerTabBarVC' could not be loaded from storyboard 'LoggerTabBar' as 'LoggerTabBarController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct login: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let loginVC = StoryboardViewControllerResource<LoginController>(identifier: "LoginVC")
      let name = "Login"

      func loginVC(_: Void = ()) -> LoginController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: loginVC)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icFacebook", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icFacebook' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "AppName", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'AppName' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icGoogle", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icGoogle' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "AppImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'AppImage' is used in storyboard 'Login', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.backward") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.backward' is used in storyboard 'Login', but couldn't be loaded.") } }
        if UIKit.UIImage(named: "icVK", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icVK' is used in storyboard 'Login', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'Login', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'Login', but couldn't be loaded.") }
        }
        if _R.storyboard.login().loginVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'loginVC' could not be loaded from storyboard 'Login' as 'LoginController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct mainLogger: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let name = "MainLogger"

      static func validate() throws {
        if UIKit.UIImage(named: "icLogsTabBarItem", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icLogsTabBarItem' is used in storyboard 'MainLogger', but couldn't be loaded.") }
        if UIKit.UIImage(named: "backgroundFrame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'backgroundFrame' is used in storyboard 'MainLogger', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'MainLogger', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'MainLogger', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct selectCharToPlay: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let name = "SelectCharToPlay"
      let selectCharToPlayNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "SelectCharToPlayNav")
      let selectCharacterToPlayVC = StoryboardViewControllerResource<SelectCharToPlayController>(identifier: "SelectCharacterToPlayVC")

      func selectCharToPlayNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: selectCharToPlayNav)
      }

      func selectCharacterToPlayVC(_: Void = ()) -> SelectCharToPlayController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: selectCharacterToPlayVC)
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.backward") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.backward' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") }
        }
        if _R.storyboard.selectCharToPlay().selectCharToPlayNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'selectCharToPlayNav' could not be loaded from storyboard 'SelectCharToPlay' as 'UIKit.UINavigationController'.") }
        if _R.storyboard.selectCharToPlay().selectCharacterToPlayVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'selectCharacterToPlayVC' could not be loaded from storyboard 'SelectCharToPlay' as 'SelectCharToPlayController'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
