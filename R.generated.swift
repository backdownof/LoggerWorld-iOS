//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.segue` struct is generated, and contains static references to 1 view controllers.
  struct segue {
    /// This struct is generated for `CreateCharController`, and contains static references to 1 segues.
    struct createCharController {
      /// Segue identifier `loggedInWithChar`.
      static let loggedInWithChar: Rswift.StoryboardSegueIdentifier<UIKit.UIStoryboardSegue, CreateCharController, MainLogViewController> = Rswift.StoryboardSegueIdentifier(identifier: "loggedInWithChar")

      #if os(iOS) || os(tvOS)
      /// Optionally returns a typed version of segue `loggedInWithChar`.
      /// Returns nil if either the segue identifier, the source, destination, or segue types don't match.
      /// For use inside `prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?)`.
      static func loggedInWithChar(segue: UIKit.UIStoryboardSegue) -> Rswift.TypedStoryboardSegueInfo<UIKit.UIStoryboardSegue, CreateCharController, MainLogViewController>? {
        return Rswift.TypedStoryboardSegueInfo(segueIdentifier: R.segue.createCharController.loggedInWithChar, segue: segue)
      }
      #endif

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 7 storyboards.
  struct storyboard {
    /// Storyboard `Assistive`.
    static let assistive = _R.storyboard.assistive()
    /// Storyboard `CreateChar`.
    static let createChar = _R.storyboard.createChar()
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `LoggerTabBar`.
    static let loggerTabBar = _R.storyboard.loggerTabBar()
    /// Storyboard `Login`.
    static let login = _R.storyboard.login()
    /// Storyboard `MainLogger`.
    static let mainLogger = _R.storyboard.mainLogger()
    /// Storyboard `SelectCharToPlay`.
    static let selectCharToPlay = _R.storyboard.selectCharToPlay()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Assistive", bundle: ...)`
    static func assistive(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.assistive)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "CreateChar", bundle: ...)`
    static func createChar(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.createChar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LoggerTabBar", bundle: ...)`
    static func loggerTabBar(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.loggerTabBar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Login", bundle: ...)`
    static func login(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.login)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "MainLogger", bundle: ...)`
    static func mainLogger(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.mainLogger)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "SelectCharToPlay", bundle: ...)`
    static func selectCharToPlay(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.selectCharToPlay)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 8 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")
    /// Color `Blue`.
    static let blue = Rswift.ColorResource(bundle: R.hostingBundle, name: "Blue")
    /// Color `Brown`.
    static let brown = Rswift.ColorResource(bundle: R.hostingBundle, name: "Brown")
    /// Color `Creame`.
    static let creame = Rswift.ColorResource(bundle: R.hostingBundle, name: "Creame")
    /// Color `Green`.
    static let green = Rswift.ColorResource(bundle: R.hostingBundle, name: "Green")
    /// Color `Red`.
    static let red = Rswift.ColorResource(bundle: R.hostingBundle, name: "Red")
    /// Color `Yellow`.
    static let yellow = Rswift.ColorResource(bundle: R.hostingBundle, name: "Yellow")
    /// Color `charBG`.
    static let charBG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charBG")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Blue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func blue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.blue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Brown", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func brown(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.brown, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Creame", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func creame(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.creame, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Green", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func green(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.green, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Red", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func red(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.red, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Yellow", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func yellow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.yellow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charBG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charBG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charBG, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 5 files.
  struct file {
    /// Resource file `AlegreyaSC-Black.ttf`.
    static let alegreyaSCBlackTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Black", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Bold.ttf`.
    static let alegreyaSCBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Bold", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-ExtraBold.ttf`.
    static let alegreyaSCExtraBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-ExtraBold", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Medium.ttf`.
    static let alegreyaSCMediumTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Medium", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Regular.ttf`.
    static let alegreyaSCRegularTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Regular", pathExtension: "ttf")

    /// `bundle.url(forResource: "AlegreyaSC-Black", withExtension: "ttf")`
    static func alegreyaSCBlackTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBlackTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Bold", withExtension: "ttf")`
    static func alegreyaSCBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-ExtraBold", withExtension: "ttf")`
    static func alegreyaSCExtraBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCExtraBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Medium", withExtension: "ttf")`
    static func alegreyaSCMediumTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCMediumTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Regular", withExtension: "ttf")`
    static func alegreyaSCRegularTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCRegularTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 5 fonts.
  struct font: Rswift.Validatable {
    /// Font `AlegreyaSC-Black`.
    static let alegreyaSCBlack = Rswift.FontResource(fontName: "AlegreyaSC-Black")
    /// Font `AlegreyaSC-Bold`.
    static let alegreyaSCBold = Rswift.FontResource(fontName: "AlegreyaSC-Bold")
    /// Font `AlegreyaSC-ExtraBold`.
    static let alegreyaSCExtraBold = Rswift.FontResource(fontName: "AlegreyaSC-ExtraBold")
    /// Font `AlegreyaSC-Medium`.
    static let alegreyaSCMedium = Rswift.FontResource(fontName: "AlegreyaSC-Medium")
    /// Font `AlegreyaSC-Regular`.
    static let alegreyaSCRegular = Rswift.FontResource(fontName: "AlegreyaSC-Regular")

    /// `UIFont(name: "AlegreyaSC-Black", size: ...)`
    static func alegreyaSCBlack(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBlack, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Bold", size: ...)`
    static func alegreyaSCBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBold, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-ExtraBold", size: ...)`
    static func alegreyaSCExtraBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCExtraBold, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Medium", size: ...)`
    static func alegreyaSCMedium(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCMedium, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Regular", size: ...)`
    static func alegreyaSCRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCRegular, size: size)
    }

    static func validate() throws {
      if R.font.alegreyaSCBlack(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Black' could not be loaded, is 'AlegreyaSC-Black.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Bold' could not be loaded, is 'AlegreyaSC-Bold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCExtraBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-ExtraBold' could not be loaded, is 'AlegreyaSC-ExtraBold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCMedium(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Medium' could not be loaded, is 'AlegreyaSC-Medium.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Regular' could not be loaded, is 'AlegreyaSC-Regular.ttf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 10 images.
  struct image {
    /// Image `AppImage`.
    static let appImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "AppImage")
    /// Image `AppName`.
    static let appName = Rswift.ImageResource(bundle: R.hostingBundle, name: "AppName")
    /// Image `Button`.
    static let button = Rswift.ImageResource(bundle: R.hostingBundle, name: "Button")
    /// Image `backgroundFrame`.
    static let backgroundFrame = Rswift.ImageResource(bundle: R.hostingBundle, name: "backgroundFrame")
    /// Image `barHP`.
    static let barHP = Rswift.ImageResource(bundle: R.hostingBundle, name: "barHP")
    /// Image `barMP`.
    static let barMP = Rswift.ImageResource(bundle: R.hostingBundle, name: "barMP")
    /// Image `icFacebook`.
    static let icFacebook = Rswift.ImageResource(bundle: R.hostingBundle, name: "icFacebook")
    /// Image `icGoogle`.
    static let icGoogle = Rswift.ImageResource(bundle: R.hostingBundle, name: "icGoogle")
    /// Image `icVK`.
    static let icVK = Rswift.ImageResource(bundle: R.hostingBundle, name: "icVK")
    /// Image `mage`.
    static let mage = Rswift.ImageResource(bundle: R.hostingBundle, name: "mage")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "AppImage", bundle: ..., traitCollection: ...)`
    static func appImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.appImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "AppName", bundle: ..., traitCollection: ...)`
    static func appName(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.appName, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Button", bundle: ..., traitCollection: ...)`
    static func button(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.button, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "backgroundFrame", bundle: ..., traitCollection: ...)`
    static func backgroundFrame(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.backgroundFrame, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "barHP", bundle: ..., traitCollection: ...)`
    static func barHP(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.barHP, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "barMP", bundle: ..., traitCollection: ...)`
    static func barMP(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.barMP, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icFacebook", bundle: ..., traitCollection: ...)`
    static func icFacebook(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icFacebook, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icGoogle", bundle: ..., traitCollection: ...)`
    static func icGoogle(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icGoogle, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icVK", bundle: ..., traitCollection: ...)`
    static func icVK(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icVK, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "mage", bundle: ..., traitCollection: ...)`
    static func mage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mage, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"
            static let uiSceneStoryboardFile = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneStoryboardFile") ?? "Login"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 6 nibs.
  struct nib {
    /// Nib `AddCharCell`.
    static let addCharCell = _R.nib._AddCharCell()
    /// Nib `AlertView`.
    static let alertView = _R.nib._AlertView()
    /// Nib `ButtonWImage`.
    static let buttonWImage = _R.nib._ButtonWImage()
    /// Nib `ButtonWOImage`.
    static let buttonWOImage = _R.nib._ButtonWOImage()
    /// Nib `CharStatusBar`.
    static let charStatusBar = _R.nib._CharStatusBar()
    /// Nib `CharacterPickCell`.
    static let characterPickCell = _R.nib._CharacterPickCell()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AddCharCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.addCharCell) instead")
    static func addCharCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.addCharCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AlertView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.alertView) instead")
    static func alertView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.alertView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ButtonWImage", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.buttonWImage) instead")
    static func buttonWImage(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.buttonWImage)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ButtonWOImage", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.buttonWOImage) instead")
    static func buttonWOImage(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.buttonWOImage)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CharStatusBar", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.charStatusBar) instead")
    static func charStatusBar(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.charStatusBar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CharacterPickCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.characterPickCell) instead")
    static func characterPickCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.characterPickCell)
    }
    #endif

    static func addCharCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AddCharCell? {
      return R.nib.addCharCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AddCharCell
    }

    static func alertView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AlertView? {
      return R.nib.alertView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AlertView
    }

    static func buttonWImage(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
      return R.nib.buttonWImage.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
    }

    static func buttonWOImage(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
      return R.nib.buttonWOImage.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
    }

    static func charStatusBar(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.charStatusBar.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func characterPickCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharacterPickCell? {
      return R.nib.characterPickCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharacterPickCell
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 2 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `cell.CharacterPick`.
    static let cellCharacterPick: Rswift.ReuseIdentifier<UIKit.UITableViewCell> = Rswift.ReuseIdentifier(identifier: "cell.CharacterPick")
    /// Reuse identifier `createdCharacters`.
    static let createdCharacters: Rswift.ReuseIdentifier<UIKit.UITableViewCell> = Rswift.ReuseIdentifier(identifier: "createdCharacters")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 2 localization tables.
  struct string {
    /// This `R.string.infoPlist` struct is generated, and contains static references to 0 localization keys.
    struct infoPlist {
      fileprivate init() {}
    }

    /// This `R.string.localizable` struct is generated, and contains static references to 4 localization keys.
    struct localizable {
      /// en translation: Cannot read data received from server.
      ///
      /// Locales: en
      static let parserError = Rswift.StringResource(key: "parserError", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Login required
      ///
      /// Locales: en
      static let errorMessageNotAuthorized = Rswift.StringResource(key: "errorMessageNotAuthorized", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: No internet connection
      ///
      /// Locales: en
      static let errorMessageInternetConnection = Rswift.StringResource(key: "errorMessageInternetConnection", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Sorry, something went wrong. Try again later.
      ///
      /// Locales: en
      static let errorMessageDefault = Rswift.StringResource(key: "errorMessageDefault", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)

      /// en translation: Cannot read data received from server.
      ///
      /// Locales: en
      static func parserError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("parserError", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "parserError"
        }

        return NSLocalizedString("parserError", bundle: bundle, comment: "")
      }

      /// en translation: Login required
      ///
      /// Locales: en
      static func errorMessageNotAuthorized(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageNotAuthorized", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageNotAuthorized"
        }

        return NSLocalizedString("errorMessageNotAuthorized", bundle: bundle, comment: "")
      }

      /// en translation: No internet connection
      ///
      /// Locales: en
      static func errorMessageInternetConnection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageInternetConnection", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageInternetConnection"
        }

        return NSLocalizedString("errorMessageInternetConnection", bundle: bundle, comment: "")
      }

      /// en translation: Sorry, something went wrong. Try again later.
      ///
      /// Locales: en
      static func errorMessageDefault(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageDefault", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageDefault"
        }

        return NSLocalizedString("errorMessageDefault", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _AddCharCell.validate()
      try _AlertView.validate()
      try _ButtonWImage.validate()
      try _ButtonWOImage.validate()
      try _CharStatusBar.validate()
      try _CharacterPickCell.validate()
    }

    struct _AddCharCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AddCharCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AddCharCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AddCharCell
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "plus") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'plus' is used in nib 'AddCharCell', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'AddCharCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _AlertView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AlertView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AlertView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AlertView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "backgroundFrame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'backgroundFrame' is used in nib 'AlertView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'AlertView', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ButtonWImage: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "ButtonWImage"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
      }

      static func validate() throws {
        if UIKit.UIImage(named: "Button", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'Button' is used in nib 'ButtonWImage', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'ButtonWImage', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ButtonWOImage: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "ButtonWOImage"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
      }

      static func validate() throws {
        if UIKit.UIImage(named: "Button", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'Button' is used in nib 'ButtonWOImage', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'ButtonWOImage', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CharStatusBar: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CharStatusBar"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "barMP", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'barMP' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "barHP", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'barHP' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in nib 'CharStatusBar', but couldn't be loaded.") }
          if UIKit.UIColor(named: "charBG", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'charBG' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CharacterPickCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CharacterPickCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharacterPickCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharacterPickCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "mage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'mage' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Green", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Green' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try assistive.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try createChar.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try loggerTabBar.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try login.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try mainLogger.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try selectCharToPlay.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct assistive: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let assistiveNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "AssistiveNav")
      let bundle = R.hostingBundle
      let name = "Assistive"

      func assistiveNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: assistiveNav)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.assistive().assistiveNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'assistiveNav' could not be loaded from storyboard 'Assistive' as 'UIKit.UINavigationController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct createChar: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let name = "CreateChar"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct loggerTabBar: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = LoggerTabBarController

      let bundle = R.hostingBundle
      let loggerTabBar = StoryboardViewControllerResource<LoggerTabBarController>(identifier: "LoggerTabBar")
      let name = "LoggerTabBar"

      func loggerTabBar(_: Void = ()) -> LoggerTabBarController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: loggerTabBar)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "backgroundFrame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'backgroundFrame' is used in storyboard 'LoggerTabBar', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.loggerTabBar().loggerTabBar() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'loggerTabBar' could not be loaded from storyboard 'LoggerTabBar' as 'LoggerTabBarController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct login: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let loginVC = StoryboardViewControllerResource<LoginController>(identifier: "LoginVC")
      let name = "Login"

      func loginVC(_: Void = ()) -> LoginController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: loginVC)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icFacebook", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icFacebook' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icVK", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icVK' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icGoogle", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icGoogle' is used in storyboard 'Login', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.backward") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.backward' is used in storyboard 'Login', but couldn't be loaded.") } }
        if UIKit.UIImage(named: "AppImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'AppImage' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "AppName", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'AppName' is used in storyboard 'Login', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'Login', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'Login', but couldn't be loaded.") }
        }
        if _R.storyboard.login().loginVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'loginVC' could not be loaded from storyboard 'Login' as 'LoginController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct mainLogger: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let mainLoggerNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "MainLoggerNav")
      let mainLoggerVC = StoryboardViewControllerResource<MainLoggerController>(identifier: "MainLoggerVC")
      let name = "MainLogger"

      func mainLoggerNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: mainLoggerNav)
      }

      func mainLoggerVC(_: Void = ()) -> MainLoggerController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: mainLoggerVC)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'MainLogger', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'MainLogger', but couldn't be loaded.") }
        }
        if _R.storyboard.mainLogger().mainLoggerNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'mainLoggerNav' could not be loaded from storyboard 'MainLogger' as 'UIKit.UINavigationController'.") }
        if _R.storyboard.mainLogger().mainLoggerVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'mainLoggerVC' could not be loaded from storyboard 'MainLogger' as 'MainLoggerController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct selectCharToPlay: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let name = "SelectCharToPlay"
      let selectCharToPlay = StoryboardViewControllerResource<SelectCharToPlayController>(identifier: "SelectCharToPlay")
      let selectCharToPlayNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "SelectCharToPlayNav")

      func selectCharToPlay(_: Void = ()) -> SelectCharToPlayController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: selectCharToPlay)
      }

      func selectCharToPlayNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: selectCharToPlayNav)
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.backward") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.backward' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") }
        }
        if _R.storyboard.selectCharToPlay().selectCharToPlay() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'selectCharToPlay' could not be loaded from storyboard 'SelectCharToPlay' as 'SelectCharToPlayController'.") }
        if _R.storyboard.selectCharToPlay().selectCharToPlayNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'selectCharToPlayNav' could not be loaded from storyboard 'SelectCharToPlay' as 'UIKit.UINavigationController'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
