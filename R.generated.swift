//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 7 storyboards.
  struct storyboard {
    /// Storyboard `Assistive`.
    static let assistive = _R.storyboard.assistive()
    /// Storyboard `CreateChar`.
    static let createChar = _R.storyboard.createChar()
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `LoggerTabBar`.
    static let loggerTabBar = _R.storyboard.loggerTabBar()
    /// Storyboard `Login`.
    static let login = _R.storyboard.login()
    /// Storyboard `MainLogger`.
    static let mainLogger = _R.storyboard.mainLogger()
    /// Storyboard `SelectCharToPlay`.
    static let selectCharToPlay = _R.storyboard.selectCharToPlay()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Assistive", bundle: ...)`
    static func assistive(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.assistive)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "CreateChar", bundle: ...)`
    static func createChar(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.createChar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LoggerTabBar", bundle: ...)`
    static func loggerTabBar(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.loggerTabBar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Login", bundle: ...)`
    static func login(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.login)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "MainLogger", bundle: ...)`
    static func mainLogger(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.mainLogger)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "SelectCharToPlay", bundle: ...)`
    static func selectCharToPlay(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.selectCharToPlay)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 12 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")
    /// Color `Blue`.
    static let blue = Rswift.ColorResource(bundle: R.hostingBundle, name: "Blue")
    /// Color `Brown`.
    static let brown = Rswift.ColorResource(bundle: R.hostingBundle, name: "Brown")
    /// Color `Creame`.
    static let creame = Rswift.ColorResource(bundle: R.hostingBundle, name: "Creame")
    /// Color `Green`.
    static let green = Rswift.ColorResource(bundle: R.hostingBundle, name: "Green")
    /// Color `Red`.
    static let red = Rswift.ColorResource(bundle: R.hostingBundle, name: "Red")
    /// Color `Yellow`.
    static let yellow = Rswift.ColorResource(bundle: R.hostingBundle, name: "Yellow")
    /// Color `charBG`.
    static let charBG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charBG")
    /// Color `charHero1BG`.
    static let charHero1BG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charHero1BG")
    /// Color `charHero2BG`.
    static let charHero2BG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charHero2BG")
    /// Color `charPKBG`.
    static let charPKBG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charPKBG")
    /// Color `charPVPBG`.
    static let charPVPBG = Rswift.ColorResource(bundle: R.hostingBundle, name: "charPVPBG")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Blue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func blue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.blue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Brown", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func brown(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.brown, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Creame", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func creame(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.creame, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Green", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func green(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.green, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Red", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func red(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.red, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Yellow", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func yellow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.yellow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charBG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charBG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charBG, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charHero1BG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charHero1BG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charHero1BG, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charHero2BG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charHero2BG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charHero2BG, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charPKBG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charPKBG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charPKBG, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "charPVPBG", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func charPVPBG(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.charPVPBG, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 10 files.
  struct file {
    /// Resource file `AlegreyaSC-Black.ttf`.
    static let alegreyaSCBlackTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Black", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-BlackItalic.ttf`.
    static let alegreyaSCBlackItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-BlackItalic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Bold.ttf`.
    static let alegreyaSCBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Bold", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-BoldItalic.ttf`.
    static let alegreyaSCBoldItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-BoldItalic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-ExtraBold.ttf`.
    static let alegreyaSCExtraBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-ExtraBold", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-ExtraBoldItalic.ttf`.
    static let alegreyaSCExtraBoldItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-ExtraBoldItalic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Italic.ttf`.
    static let alegreyaSCItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Italic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Medium.ttf`.
    static let alegreyaSCMediumTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Medium", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-MediumItalic.ttf`.
    static let alegreyaSCMediumItalicTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-MediumItalic", pathExtension: "ttf")
    /// Resource file `AlegreyaSC-Regular.ttf`.
    static let alegreyaSCRegularTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AlegreyaSC-Regular", pathExtension: "ttf")

    /// `bundle.url(forResource: "AlegreyaSC-Black", withExtension: "ttf")`
    static func alegreyaSCBlackTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBlackTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-BlackItalic", withExtension: "ttf")`
    static func alegreyaSCBlackItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBlackItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Bold", withExtension: "ttf")`
    static func alegreyaSCBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-BoldItalic", withExtension: "ttf")`
    static func alegreyaSCBoldItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCBoldItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-ExtraBold", withExtension: "ttf")`
    static func alegreyaSCExtraBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCExtraBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-ExtraBoldItalic", withExtension: "ttf")`
    static func alegreyaSCExtraBoldItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCExtraBoldItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Italic", withExtension: "ttf")`
    static func alegreyaSCItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Medium", withExtension: "ttf")`
    static func alegreyaSCMediumTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCMediumTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-MediumItalic", withExtension: "ttf")`
    static func alegreyaSCMediumItalicTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCMediumItalicTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AlegreyaSC-Regular", withExtension: "ttf")`
    static func alegreyaSCRegularTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.alegreyaSCRegularTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 10 fonts.
  struct font: Rswift.Validatable {
    /// Font `AlegreyaSC-BlackItalic`.
    static let alegreyaSCBlackItalic = Rswift.FontResource(fontName: "AlegreyaSC-BlackItalic")
    /// Font `AlegreyaSC-Black`.
    static let alegreyaSCBlack = Rswift.FontResource(fontName: "AlegreyaSC-Black")
    /// Font `AlegreyaSC-BoldItalic`.
    static let alegreyaSCBoldItalic = Rswift.FontResource(fontName: "AlegreyaSC-BoldItalic")
    /// Font `AlegreyaSC-Bold`.
    static let alegreyaSCBold = Rswift.FontResource(fontName: "AlegreyaSC-Bold")
    /// Font `AlegreyaSC-ExtraBoldItalic`.
    static let alegreyaSCExtraBoldItalic = Rswift.FontResource(fontName: "AlegreyaSC-ExtraBoldItalic")
    /// Font `AlegreyaSC-ExtraBold`.
    static let alegreyaSCExtraBold = Rswift.FontResource(fontName: "AlegreyaSC-ExtraBold")
    /// Font `AlegreyaSC-Italic`.
    static let alegreyaSCItalic = Rswift.FontResource(fontName: "AlegreyaSC-Italic")
    /// Font `AlegreyaSC-MediumItalic`.
    static let alegreyaSCMediumItalic = Rswift.FontResource(fontName: "AlegreyaSC-MediumItalic")
    /// Font `AlegreyaSC-Medium`.
    static let alegreyaSCMedium = Rswift.FontResource(fontName: "AlegreyaSC-Medium")
    /// Font `AlegreyaSC-Regular`.
    static let alegreyaSCRegular = Rswift.FontResource(fontName: "AlegreyaSC-Regular")

    /// `UIFont(name: "AlegreyaSC-Black", size: ...)`
    static func alegreyaSCBlack(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBlack, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-BlackItalic", size: ...)`
    static func alegreyaSCBlackItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBlackItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Bold", size: ...)`
    static func alegreyaSCBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBold, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-BoldItalic", size: ...)`
    static func alegreyaSCBoldItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCBoldItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-ExtraBold", size: ...)`
    static func alegreyaSCExtraBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCExtraBold, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-ExtraBoldItalic", size: ...)`
    static func alegreyaSCExtraBoldItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCExtraBoldItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Italic", size: ...)`
    static func alegreyaSCItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Medium", size: ...)`
    static func alegreyaSCMedium(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCMedium, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-MediumItalic", size: ...)`
    static func alegreyaSCMediumItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCMediumItalic, size: size)
    }

    /// `UIFont(name: "AlegreyaSC-Regular", size: ...)`
    static func alegreyaSCRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: alegreyaSCRegular, size: size)
    }

    static func validate() throws {
      if R.font.alegreyaSCBlack(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Black' could not be loaded, is 'AlegreyaSC-Black.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCBlackItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-BlackItalic' could not be loaded, is 'AlegreyaSC-BlackItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Bold' could not be loaded, is 'AlegreyaSC-Bold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCBoldItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-BoldItalic' could not be loaded, is 'AlegreyaSC-BoldItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCExtraBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-ExtraBold' could not be loaded, is 'AlegreyaSC-ExtraBold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCExtraBoldItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-ExtraBoldItalic' could not be loaded, is 'AlegreyaSC-ExtraBoldItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Italic' could not be loaded, is 'AlegreyaSC-Italic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCMedium(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Medium' could not be loaded, is 'AlegreyaSC-Medium.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCMediumItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-MediumItalic' could not be loaded, is 'AlegreyaSC-MediumItalic.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.alegreyaSCRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AlegreyaSC-Regular' could not be loaded, is 'AlegreyaSC-Regular.ttf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.id` struct is generated, and contains static references to accessibility identifiers.
  struct id {
    struct createChar {
      /// Accessibility identifier `ARCHER`.
      static let archeR: String = "ARCHER"
      /// Accessibility identifier `ASSASSIN`.
      static let assassiN: String = "ASSASSIN"
      /// Accessibility identifier `WARRIOR`.
      static let warrioR: String = "WARRIOR"
      /// Accessibility identifier `WIZARD`.
      static let wizarD: String = "WIZARD"

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 19 images.
  struct image {
    /// Image `AppImage`.
    static let appImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "AppImage")
    /// Image `AppName`.
    static let appName = Rswift.ImageResource(bundle: R.hostingBundle, name: "AppName")
    /// Image `Button`.
    static let button = Rswift.ImageResource(bundle: R.hostingBundle, name: "Button")
    /// Image `archerImage`.
    static let archerImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "archerImage")
    /// Image `assassinImage`.
    static let assassinImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "assassinImage")
    /// Image `backgroundFrame`.
    static let backgroundFrame = Rswift.ImageResource(bundle: R.hostingBundle, name: "backgroundFrame")
    /// Image `barHP`.
    static let barHP = Rswift.ImageResource(bundle: R.hostingBundle, name: "barHP")
    /// Image `barMP`.
    static let barMP = Rswift.ImageResource(bundle: R.hostingBundle, name: "barMP")
    /// Image `icArcherBow`.
    static let icArcherBow = Rswift.ImageResource(bundle: R.hostingBundle, name: "icArcherBow")
    /// Image `icAssasignShuriken`.
    static let icAssasignShuriken = Rswift.ImageResource(bundle: R.hostingBundle, name: "icAssasignShuriken")
    /// Image `icFacebook`.
    static let icFacebook = Rswift.ImageResource(bundle: R.hostingBundle, name: "icFacebook")
    /// Image `icGoogle`.
    static let icGoogle = Rswift.ImageResource(bundle: R.hostingBundle, name: "icGoogle")
    /// Image `icInventoryTabBarItem`.
    static let icInventoryTabBarItem = Rswift.ImageResource(bundle: R.hostingBundle, name: "icInventoryTabBarItem")
    /// Image `icLogsTabBarItem`.
    static let icLogsTabBarItem = Rswift.ImageResource(bundle: R.hostingBundle, name: "icLogsTabBarItem")
    /// Image `icMageStuff`.
    static let icMageStuff = Rswift.ImageResource(bundle: R.hostingBundle, name: "icMageStuff")
    /// Image `icVK`.
    static let icVK = Rswift.ImageResource(bundle: R.hostingBundle, name: "icVK")
    /// Image `icWarSword`.
    static let icWarSword = Rswift.ImageResource(bundle: R.hostingBundle, name: "icWarSword")
    /// Image `mageImage`.
    static let mageImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "mageImage")
    /// Image `warriorImage`.
    static let warriorImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "warriorImage")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "AppImage", bundle: ..., traitCollection: ...)`
    static func appImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.appImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "AppName", bundle: ..., traitCollection: ...)`
    static func appName(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.appName, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Button", bundle: ..., traitCollection: ...)`
    static func button(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.button, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "archerImage", bundle: ..., traitCollection: ...)`
    static func archerImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.archerImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "assassinImage", bundle: ..., traitCollection: ...)`
    static func assassinImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.assassinImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "backgroundFrame", bundle: ..., traitCollection: ...)`
    static func backgroundFrame(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.backgroundFrame, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "barHP", bundle: ..., traitCollection: ...)`
    static func barHP(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.barHP, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "barMP", bundle: ..., traitCollection: ...)`
    static func barMP(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.barMP, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icArcherBow", bundle: ..., traitCollection: ...)`
    static func icArcherBow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icArcherBow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icAssasignShuriken", bundle: ..., traitCollection: ...)`
    static func icAssasignShuriken(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icAssasignShuriken, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icFacebook", bundle: ..., traitCollection: ...)`
    static func icFacebook(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icFacebook, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icGoogle", bundle: ..., traitCollection: ...)`
    static func icGoogle(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icGoogle, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icInventoryTabBarItem", bundle: ..., traitCollection: ...)`
    static func icInventoryTabBarItem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icInventoryTabBarItem, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icLogsTabBarItem", bundle: ..., traitCollection: ...)`
    static func icLogsTabBarItem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icLogsTabBarItem, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icMageStuff", bundle: ..., traitCollection: ...)`
    static func icMageStuff(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icMageStuff, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icVK", bundle: ..., traitCollection: ...)`
    static func icVK(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icVK, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "icWarSword", bundle: ..., traitCollection: ...)`
    static func icWarSword(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.icWarSword, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "mageImage", bundle: ..., traitCollection: ...)`
    static func mageImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.mageImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "warriorImage", bundle: ..., traitCollection: ...)`
    static func warriorImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.warriorImage, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"
            static let uiSceneStoryboardFile = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneStoryboardFile") ?? "Login"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 7 nibs.
  struct nib {
    /// Nib `AddCharCell`.
    static let addCharCell = _R.nib._AddCharCell()
    /// Nib `AlertView`.
    static let alertView = _R.nib._AlertView()
    /// Nib `ButtonWImage`.
    static let buttonWImage = _R.nib._ButtonWImage()
    /// Nib `ButtonWOImage`.
    static let buttonWOImage = _R.nib._ButtonWOImage()
    /// Nib `CharStatusBar`.
    static let charStatusBar = _R.nib._CharStatusBar()
    /// Nib `CharacterPickCell`.
    static let characterPickCell = _R.nib._CharacterPickCell()
    /// Nib `CharsInLocationCell`.
    static let charsInLocationCell = _R.nib._CharsInLocationCell()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AddCharCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.addCharCell) instead")
    static func addCharCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.addCharCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AlertView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.alertView) instead")
    static func alertView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.alertView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ButtonWImage", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.buttonWImage) instead")
    static func buttonWImage(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.buttonWImage)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ButtonWOImage", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.buttonWOImage) instead")
    static func buttonWOImage(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.buttonWOImage)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CharStatusBar", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.charStatusBar) instead")
    static func charStatusBar(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.charStatusBar)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CharacterPickCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.characterPickCell) instead")
    static func characterPickCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.characterPickCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CharsInLocationCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.charsInLocationCell) instead")
    static func charsInLocationCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.charsInLocationCell)
    }
    #endif

    static func addCharCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AddCharCell? {
      return R.nib.addCharCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AddCharCell
    }

    static func alertView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AlertView? {
      return R.nib.alertView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AlertView
    }

    static func buttonWImage(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
      return R.nib.buttonWImage.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
    }

    static func buttonWOImage(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
      return R.nib.buttonWOImage.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
    }

    static func charStatusBar(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.charStatusBar.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func characterPickCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharacterPickCell? {
      return R.nib.characterPickCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharacterPickCell
    }

    static func charsInLocationCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharsInLocationCell? {
      return R.nib.charsInLocationCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharsInLocationCell
    }

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 2 localization tables.
  struct string {
    /// This `R.string.infoPlist` struct is generated, and contains static references to 0 localization keys.
    struct infoPlist {
      fileprivate init() {}
    }

    /// This `R.string.localizable` struct is generated, and contains static references to 4 localization keys.
    struct localizable {
      /// en translation: Cannot read data received from server.
      ///
      /// Locales: en
      static let parserError = Rswift.StringResource(key: "parserError", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Login required
      ///
      /// Locales: en
      static let errorMessageNotAuthorized = Rswift.StringResource(key: "errorMessageNotAuthorized", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: No internet connection
      ///
      /// Locales: en
      static let errorMessageInternetConnection = Rswift.StringResource(key: "errorMessageInternetConnection", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Sorry, something went wrong. Try again later.
      ///
      /// Locales: en
      static let errorMessageDefault = Rswift.StringResource(key: "errorMessageDefault", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)

      /// en translation: Cannot read data received from server.
      ///
      /// Locales: en
      static func parserError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("parserError", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "parserError"
        }

        return NSLocalizedString("parserError", bundle: bundle, comment: "")
      }

      /// en translation: Login required
      ///
      /// Locales: en
      static func errorMessageNotAuthorized(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageNotAuthorized", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageNotAuthorized"
        }

        return NSLocalizedString("errorMessageNotAuthorized", bundle: bundle, comment: "")
      }

      /// en translation: No internet connection
      ///
      /// Locales: en
      static func errorMessageInternetConnection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageInternetConnection", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageInternetConnection"
        }

        return NSLocalizedString("errorMessageInternetConnection", bundle: bundle, comment: "")
      }

      /// en translation: Sorry, something went wrong. Try again later.
      ///
      /// Locales: en
      static func errorMessageDefault(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("errorMessageDefault", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "errorMessageDefault"
        }

        return NSLocalizedString("errorMessageDefault", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _AddCharCell.validate()
      try _AlertView.validate()
      try _ButtonWImage.validate()
      try _ButtonWOImage.validate()
      try _CharStatusBar.validate()
      try _CharacterPickCell.validate()
      try _CharsInLocationCell.validate()
    }

    struct _AddCharCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AddCharCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AddCharCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AddCharCell
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "plus") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'plus' is used in nib 'AddCharCell', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'AddCharCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _AlertView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AlertView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AlertView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AlertView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "backgroundFrame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'backgroundFrame' is used in nib 'AlertView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'AlertView', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ButtonWImage: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "ButtonWImage"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
      }

      static func validate() throws {
        if UIKit.UIImage(named: "Button", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'Button' is used in nib 'ButtonWImage', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'ButtonWImage', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ButtonWOImage: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "ButtonWOImage"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIControl? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIControl
      }

      static func validate() throws {
        if UIKit.UIImage(named: "Button", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'Button' is used in nib 'ButtonWOImage', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'ButtonWOImage', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CharStatusBar: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CharStatusBar"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "barMP", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'barMP' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "barHP", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'barHP' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in nib 'CharStatusBar', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CharacterPickCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CharacterPickCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharacterPickCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharacterPickCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "mage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'mage' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Green", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Green' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in nib 'CharacterPickCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CharsInLocationCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CharsInLocationCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CharsInLocationCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CharsInLocationCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icWarSword", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icWarSword' is used in nib 'CharsInLocationCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in nib 'CharsInLocationCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try assistive.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try createChar.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try loggerTabBar.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try login.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try mainLogger.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try selectCharToPlay.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct assistive: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let assistiveNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "AssistiveNav")
      let bundle = R.hostingBundle
      let name = "Assistive"

      func assistiveNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: assistiveNav)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icInventoryTabBarItem", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icInventoryTabBarItem' is used in storyboard 'Assistive', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.assistive().assistiveNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'assistiveNav' could not be loaded from storyboard 'Assistive' as 'UIKit.UINavigationController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct createChar: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let createChar = StoryboardViewControllerResource<CreateCharController>(identifier: "CreateChar")
      let createCharNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "CreateCharNav")
      let name = "CreateChar"

      func createChar(_: Void = ()) -> CreateCharController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: createChar)
      }

      func createCharNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: createCharNav)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icMageStuff", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icMageStuff' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "assassinImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'assassinImage' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "warriorImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'warriorImage' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icAssasignShuriken", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icAssasignShuriken' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "archerImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'archerImage' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icWarSword", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icWarSword' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "mageImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'mageImage' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icArcherBow", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icArcherBow' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'CreateChar', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'CreateChar', but couldn't be loaded.") }
        }
        if _R.storyboard.createChar().createChar() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'createChar' could not be loaded from storyboard 'CreateChar' as 'CreateCharController'.") }
        if _R.storyboard.createChar().createCharNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'createCharNav' could not be loaded from storyboard 'CreateChar' as 'UIKit.UINavigationController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct loggerTabBar: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = LoggerTabBarController

      let bundle = R.hostingBundle
      let loggerTabBar = StoryboardViewControllerResource<LoggerTabBarController>(identifier: "LoggerTabBar")
      let name = "LoggerTabBar"

      func loggerTabBar(_: Void = ()) -> LoggerTabBarController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: loggerTabBar)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'LoggerTabBar', but couldn't be loaded.") }
        }
        if _R.storyboard.loggerTabBar().loggerTabBar() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'loggerTabBar' could not be loaded from storyboard 'LoggerTabBar' as 'LoggerTabBarController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct login: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let loginVC = StoryboardViewControllerResource<LoginController>(identifier: "LoginVC")
      let name = "Login"

      func loginVC(_: Void = ()) -> LoginController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: loginVC)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icVK", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icVK' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icGoogle", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icGoogle' is used in storyboard 'Login', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.backward") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.backward' is used in storyboard 'Login', but couldn't be loaded.") } }
        if UIKit.UIImage(named: "AppName", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'AppName' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "icFacebook", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icFacebook' is used in storyboard 'Login', but couldn't be loaded.") }
        if UIKit.UIImage(named: "AppImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'AppImage' is used in storyboard 'Login', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'Login', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'Login', but couldn't be loaded.") }
        }
        if _R.storyboard.login().loginVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'loginVC' could not be loaded from storyboard 'Login' as 'LoginController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct mainLogger: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let mainLoggerNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "MainLoggerNav")
      let mainLoggerVC = StoryboardViewControllerResource<MainLoggerController>(identifier: "MainLoggerVC")
      let name = "MainLogger"

      func mainLoggerNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: mainLoggerNav)
      }

      func mainLoggerVC(_: Void = ()) -> MainLoggerController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: mainLoggerVC)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "icLogsTabBarItem", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'icLogsTabBarItem' is used in storyboard 'MainLogger', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'MainLogger', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'MainLogger', but couldn't be loaded.") }
        }
        if _R.storyboard.mainLogger().mainLoggerNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'mainLoggerNav' could not be loaded from storyboard 'MainLogger' as 'UIKit.UINavigationController'.") }
        if _R.storyboard.mainLogger().mainLoggerVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'mainLoggerVC' could not be loaded from storyboard 'MainLogger' as 'MainLoggerController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct selectCharToPlay: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let name = "SelectCharToPlay"
      let selectCharToPlay = StoryboardViewControllerResource<SelectCharToPlayController>(identifier: "SelectCharToPlay")
      let selectCharToPlayNav = StoryboardViewControllerResource<UIKit.UINavigationController>(identifier: "SelectCharToPlayNav")

      func selectCharToPlay(_: Void = ()) -> SelectCharToPlayController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: selectCharToPlay)
      }

      func selectCharToPlayNav(_: Void = ()) -> UIKit.UINavigationController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: selectCharToPlayNav)
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.backward") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.backward' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Brown", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Brown' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") }
          if UIKit.UIColor(named: "Creame", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Creame' is used in storyboard 'SelectCharToPlay', but couldn't be loaded.") }
        }
        if _R.storyboard.selectCharToPlay().selectCharToPlay() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'selectCharToPlay' could not be loaded from storyboard 'SelectCharToPlay' as 'SelectCharToPlayController'.") }
        if _R.storyboard.selectCharToPlay().selectCharToPlayNav() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'selectCharToPlayNav' could not be loaded from storyboard 'SelectCharToPlay' as 'UIKit.UINavigationController'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
